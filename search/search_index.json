{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Packages glob","title":"glob"},{"location":"glob--index/","text":"Glob package \u00b6 The Glob package provides the ability find all pathnames matching a given pattern based on Unix shell rules. Its adapted from the glob2 python module . See primitive Glob for additional usage details. Public Types \u00b6 interface GlobHandler primitive Glob","title":"Package"},{"location":"glob--index/#glob-package","text":"The Glob package provides the ability find all pathnames matching a given pattern based on Unix shell rules. Its adapted from the glob2 python module . See primitive Glob for additional usage details.","title":"Glob package"},{"location":"glob--index/#public-types","text":"interface GlobHandler primitive Glob","title":"Public Types"},{"location":"glob-Glob/","text":"Glob \u00b6 [Source] Filename matching and globbing with shell patterns. fnmatch(file_name, pattern) matches according to the local convention. fnmatchcase(file_name, pattern) always takes case into account. The functions operate by translating the pattern into a regular expression. The function translate(PATTERN) returns a regular expression corresponding to PATTERN. Patterns are Unix shell style: * | matches multiple characters within a directory ** | matches multiple characters across directories ? | matches any single character [seq] | matches any character in seq [!seq] | matches any char not in seq primitive val Glob Constructors \u00b6 create \u00b6 [Source] new val create() : Glob val^ Returns \u00b6 Glob val^ Public Functions \u00b6 fnmatch \u00b6 [Source] Tests whether name matches pattern . An initial period in name is not special. Both name and pattern are first case-normalized if the operating system requires it. If you don't want this, use fnmatchcase . fun box fnmatch( name: String val, pattern: String val) : Bool val Parameters \u00b6 name: String val pattern: String val Returns \u00b6 Bool val fnmatchcase \u00b6 [Source] Tests whether name matches pattern , including case. fun box fnmatchcase( name: String val, pattern: String val) : Bool val Parameters \u00b6 name: String val pattern: String val Returns \u00b6 Bool val filter \u00b6 [Source] Returns name and the matching subgroups for names that match pattern . All strings are first case-normalized if the operating system requires it. fun box filter( names: Array[String val] ref, pattern: String val) : Array[(String val , Array[String val] ref)] val Parameters \u00b6 names: Array [ String val] ref pattern: String val Returns \u00b6 Array [( String val , Array [ String val] ref)] val translate \u00b6 [Source] Translates a shell pattern to a regular expression. There is no way to quote meta-characters. fun box translate( pat: String val) : String ref^ Parameters \u00b6 pat: String val Returns \u00b6 String ref^ glob \u00b6 [Source] Returns an Array[FilePath] for each path below root_path that matches pattern . The pattern may contain shell-style wildcards. See the type documentation on Glob for details. fun box glob( root_path: FilePath val, pattern: String val) : Array[FilePath val] ref Parameters \u00b6 root_path: FilePath val pattern: String val Returns \u00b6 Array [ FilePath val] ref iglob \u00b6 [Source] Calls GlobHandler.apply for each path below root that matches pattern . The pattern may contain shell-style wildcards. See the type documentation on Glob for details. fun box iglob( root: FilePath val, pattern: String val, glob_handler: GlobHandler ref) : None val Parameters \u00b6 root: FilePath val pattern: String val glob_handler: GlobHandler ref Returns \u00b6 None val eq \u00b6 [Source] fun box eq( that: Glob val) : Bool val Parameters \u00b6 that: Glob val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: Glob val) : Bool val Parameters \u00b6 that: Glob val Returns \u00b6 Bool val","title":"primitive Glob"},{"location":"glob-Glob/#glob","text":"[Source] Filename matching and globbing with shell patterns. fnmatch(file_name, pattern) matches according to the local convention. fnmatchcase(file_name, pattern) always takes case into account. The functions operate by translating the pattern into a regular expression. The function translate(PATTERN) returns a regular expression corresponding to PATTERN. Patterns are Unix shell style: * | matches multiple characters within a directory ** | matches multiple characters across directories ? | matches any single character [seq] | matches any character in seq [!seq] | matches any char not in seq primitive val Glob","title":"Glob"},{"location":"glob-Glob/#constructors","text":"","title":"Constructors"},{"location":"glob-Glob/#create","text":"[Source] new val create() : Glob val^","title":"create"},{"location":"glob-Glob/#returns","text":"Glob val^","title":"Returns"},{"location":"glob-Glob/#public-functions","text":"","title":"Public Functions"},{"location":"glob-Glob/#fnmatch","text":"[Source] Tests whether name matches pattern . An initial period in name is not special. Both name and pattern are first case-normalized if the operating system requires it. If you don't want this, use fnmatchcase . fun box fnmatch( name: String val, pattern: String val) : Bool val","title":"fnmatch"},{"location":"glob-Glob/#parameters","text":"name: String val pattern: String val","title":"Parameters"},{"location":"glob-Glob/#returns_1","text":"Bool val","title":"Returns"},{"location":"glob-Glob/#fnmatchcase","text":"[Source] Tests whether name matches pattern , including case. fun box fnmatchcase( name: String val, pattern: String val) : Bool val","title":"fnmatchcase"},{"location":"glob-Glob/#parameters_1","text":"name: String val pattern: String val","title":"Parameters"},{"location":"glob-Glob/#returns_2","text":"Bool val","title":"Returns"},{"location":"glob-Glob/#filter","text":"[Source] Returns name and the matching subgroups for names that match pattern . All strings are first case-normalized if the operating system requires it. fun box filter( names: Array[String val] ref, pattern: String val) : Array[(String val , Array[String val] ref)] val","title":"filter"},{"location":"glob-Glob/#parameters_2","text":"names: Array [ String val] ref pattern: String val","title":"Parameters"},{"location":"glob-Glob/#returns_3","text":"Array [( String val , Array [ String val] ref)] val","title":"Returns"},{"location":"glob-Glob/#translate","text":"[Source] Translates a shell pattern to a regular expression. There is no way to quote meta-characters. fun box translate( pat: String val) : String ref^","title":"translate"},{"location":"glob-Glob/#parameters_3","text":"pat: String val","title":"Parameters"},{"location":"glob-Glob/#returns_4","text":"String ref^","title":"Returns"},{"location":"glob-Glob/#glob_1","text":"[Source] Returns an Array[FilePath] for each path below root_path that matches pattern . The pattern may contain shell-style wildcards. See the type documentation on Glob for details. fun box glob( root_path: FilePath val, pattern: String val) : Array[FilePath val] ref","title":"glob"},{"location":"glob-Glob/#parameters_4","text":"root_path: FilePath val pattern: String val","title":"Parameters"},{"location":"glob-Glob/#returns_5","text":"Array [ FilePath val] ref","title":"Returns"},{"location":"glob-Glob/#iglob","text":"[Source] Calls GlobHandler.apply for each path below root that matches pattern . The pattern may contain shell-style wildcards. See the type documentation on Glob for details. fun box iglob( root: FilePath val, pattern: String val, glob_handler: GlobHandler ref) : None val","title":"iglob"},{"location":"glob-Glob/#parameters_5","text":"root: FilePath val pattern: String val glob_handler: GlobHandler ref","title":"Parameters"},{"location":"glob-Glob/#returns_6","text":"None val","title":"Returns"},{"location":"glob-Glob/#eq","text":"[Source] fun box eq( that: Glob val) : Bool val","title":"eq"},{"location":"glob-Glob/#parameters_6","text":"that: Glob val","title":"Parameters"},{"location":"glob-Glob/#returns_7","text":"Bool val","title":"Returns"},{"location":"glob-Glob/#ne","text":"[Source] fun box ne( that: Glob val) : Bool val","title":"ne"},{"location":"glob-Glob/#parameters_7","text":"that: Glob val","title":"Parameters"},{"location":"glob-Glob/#returns_8","text":"Bool val","title":"Returns"},{"location":"glob-GlobHandler/","text":"GlobHandler \u00b6 [Source] A handler for Glob.iglob . Each path which matches the glob will be called with the groups that matched the various wildcards supplies in the match_groups array. interface ref GlobHandler Public Functions \u00b6 apply \u00b6 [Source] fun ref apply( path: FilePath val, match_groups: Array[String val] ref) : None val Parameters \u00b6 path: FilePath val match_groups: Array [ String val] ref Returns \u00b6 None val","title":"interface GlobHandler"},{"location":"glob-GlobHandler/#globhandler","text":"[Source] A handler for Glob.iglob . Each path which matches the glob will be called with the groups that matched the various wildcards supplies in the match_groups array. interface ref GlobHandler","title":"GlobHandler"},{"location":"glob-GlobHandler/#public-functions","text":"","title":"Public Functions"},{"location":"glob-GlobHandler/#apply","text":"[Source] fun ref apply( path: FilePath val, match_groups: Array[String val] ref) : None val","title":"apply"},{"location":"glob-GlobHandler/#parameters","text":"path: FilePath val match_groups: Array [ String val] ref","title":"Parameters"},{"location":"glob-GlobHandler/#returns","text":"None val","title":"Returns"},{"location":"src/glob/glob/","text":"\"\"\" # Glob package The Glob package provides the ability find all pathnames matching a given pattern based on Unix shell rules. Its adapted from the [glob2 python module](https://github.com/miracle2k/python-glob2). See `primitive Glob` for additional usage details. \"\"\" use \"files\" use \"regex\" interface GlobHandler \"\"\" A handler for `Glob.iglob`. Each path which matches the glob will be called with the groups that matched the various wildcards supplies in the `match_groups` array. \"\"\" fun ref apply(path: FilePath, match_groups: Array[String]) primitive Glob \"\"\" Filename matching and globbing with shell patterns. `fnmatch(file_name, pattern)` matches according to the local convention. `fnmatchcase(file_name, pattern)` always takes case into account. The functions operate by translating the pattern into a regular expression. The function translate(PATTERN) returns a regular expression corresponding to PATTERN. Patterns are Unix shell style: * | matches multiple characters within a directory ** | matches multiple characters across directories ? | matches any single character [seq] | matches any character in seq [!seq] | matches any char not in seq \"\"\" fun fnmatch(name: String, pattern: String): Bool => \"\"\" Tests whether `name` matches `pattern`. An initial period in `name` is not special. Both `name` and `pattern` are first case-normalized if the operating system requires it. If you don't want this, use `fnmatchcase`. \"\"\" fnmatchcase(Path.normcase(name), Path.normcase(pattern)) fun fnmatchcase(name: String, pattern: String): Bool => \"\"\"Tests whether `name` matches `pattern`, including case.\"\"\" try Regex(translate(pattern))? == name else false end fun filter(names: Array[String], pattern: String) : Array[(String, Array[String])] val => \"\"\" Returns `name` and the matching subgroups for `names` that match `pattern`. All strings are first case-normalized if the operating system requires it. \"\"\" let result = recover Array[(String, Array[String])] end try let regex = Regex(translate(Path.normcase(pattern)))? for name in names.values() do try let m = regex(Path.normcase(name))? result.push((name, m.groups())) end end end result fun translate(pat: String): String ref^ => \"\"\" Translates a shell `pattern` to a regular expression. There is no way to quote meta-characters. \"\"\" let n = pat.size() let res = String(n) res.append(\"\\\\A\") // start of string try let alpha_num_regex = Regex(\"\\\\w\")? var i: USize = 0 while i < n do let c = pat(i)? i = i + 1 if c == '*' then if (i < n) and (pat(i)? == '*') then res.append(\"(.*)\") i = i + 1 else res.append(\"([^/]*)\") end elseif c == '?' then res.append(\"([^/])\") elseif c == '[' then var j = i if (j < n) then if pat(j)? == '!' then j = j + 1 elseif pat(j)? == ']' then j = j + 1 end end while (j < n) and (pat(j)? != ']') do j = j + 1 end if j >= n then res.append(\"\\\\[\") else res.append(\"([\") if pat(i)? == '!' then res.append(\"^\") i = i + 1 elseif pat(i)? == '^' then res.append(\"\\\\^\") i = i + 1 end let sub = recover ref pat.substring(i.isize(), j.isize()) end res.append(sub .> replace(\"\\\\\",\"\\\\\\\\\")) res.append(\"])\") i = j + 1 end else if alpha_num_regex != String(1) .> push(c) then res.append(\"\\\\\") end res.push(c) end end // end of string + (?ms) multiline and dotall flags res.append(\"\\\\Z(?ms)\") end res fun glob(root_path: FilePath, pattern: String): Array[FilePath] => \"\"\" Returns an Array[FilePath] for each path below `root_path` that matches `pattern`. The pattern may contain shell-style wildcards. See the type documentation on `Glob` for details. \"\"\" let res = Array[FilePath] iglob(root_path, pattern, {(path, _) => res.push(path)}) res fun _apply_glob_to_walk( pattern: String, compiled_pattern: Regex, root: FilePath, glob_handler: GlobHandler ref, dir: FilePath, entries: Array[String] ref) => for e in entries.values() do try let p = dir.join(e)? let m = compiled_pattern( if Path.is_abs(pattern) then p.path else Path.rel(root.path, p.path)? end)? glob_handler(p, m.groups()) end end fun iglob(root: FilePath, pattern: String, glob_handler: GlobHandler ref) => \"\"\" Calls `GlobHandler.apply` for each path below `root` that matches `pattern`. The pattern may contain shell-style wildcards. See the type documentation on `Glob` for details. \"\"\" // TODO: do something efficient by looking at parts of the pattern that do // not contain wildcards and expanding them before walking. try root.walk(this~_apply_glob_to_walk( pattern, Regex(translate(Path.normcase(pattern)))?, root, glob_handler)) end","title":"Glob"}]}